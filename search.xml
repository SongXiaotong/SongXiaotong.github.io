<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超级基础实用的TAPD使用指南]]></title>
    <url>%2F2019%2F06%2F27%2FTAPD%2F</url>
    <content type="text"><![CDATA[TAPD简介TAPD（Tencent Agile Product Development）全名为腾讯敏捷产品研发平台，已在腾讯内部运营12年，并于2017年5月正式对外开放。TAPD的主要作用是帮助项目管理者更好进行项目管理，为项目人员提供一系列项目协作解决方案。 TAPD主要提供看板、在线文档、敏捷需求规划、迭代计划&amp;跟踪、任务工时管理、缺陷跟踪管理、测试计划&amp;用例、持续集成、持续交付&amp;部署等丰富的可配置功能，并提供三种敏捷协作解决方案，满足不同客户场景需要： 1、轻量协作解决方案：适用于不同行业协作场景，满足任务协同，文档协作和沟通交流的场景所需，帮助团队可视化工作进展、沉淀分享项目知识、提升团队协作效率。 2、敏捷研发解决方案：专为产品研发场景打造，针对研发痛点，提供贯穿敏捷研发生命周期的一站式服务，帮助团队提升研发效率，高质量交付成功产品。 3、Devops解决方案：专为DevOps持续交付场景打造，深度整合研发工具链，助力团队高效、可靠地构建与发布产品，快速交付用户价值。 使用指南很好上面的内容看看就行，接下来才是真正有用的地方，可以免费试用的TAPD分为标准版和专业版，我注册的是专业版，包含需求、迭代、故事墙、缺陷、报表、文档等6个核心应用，还支持通过移动端管理工作。 下面将为大家介绍几种TAPD最常用的工具用法，干货满满！ 任务列表任务列表在TAPD中体现的是工作台，这是左侧主菜单栏的第一个子项。 在工作台下，我们可以看到，TAPD将所有的任务划分为我的待办、我的已办、我创建的以及我关注的，从这个界面我们可以快速了解到我们需要完成的任务，并对已经完成的任务进行二次检查。 在线文档对于项目人员尤其是产品工作者来说，编写文档是必须而且是重中之重的时，在线文档协作的功能更是必不可少的，一款能够支持多成员实时协作的文档编辑软件在团队项目开发过程中一定是备受青睐的。 TAPD支持普通文档与思维导图的创建，文档的创建就是一个在线的编辑器，满足简单的排版需求，思维导图也是同理，两种文本与图形工具操作简单，不多做解释 项目项目是TAPD的基本工作单位，也是我们进入TAPD时看到的第一个页面，在左侧主菜单列表的第三个选项“项目”中也可以快速进入某个项目。我们前面使用的个人文档和工作台事项都是从项目中延伸出来的功能。 TAPD为用户提供了四种项目模板，分别为轻量团队面板，问题跟踪管理，轻量敏捷项目管理，以及敏捷全生命周期管理，根据公司的规模等注册信息的不同，我们可选的模板范围是不同的，我在注册专业版时选择的为1-10人团队，在项目创建的位置上允许我选择三种项目。 输入项目标题和项目描述，这样一个简单的模板项目就创建成功了 创建项目后，系统会提示我们导入成员，此时根据需要邀请即可，也可以暂时不进行操作。 添加成员后，这个项目就可以正常运行了，项目内部的使用根据模板的不同有不同的核心内容，这部分我们稍后再说，我们先来说如何进行项目管理。 进入项目管理只需要点击最上方的设置图标即可进入项目管理界面，TAPD对于界面的设置主体使用卡片式结构，也充分利用了菜单层级的设计，逻辑构图相当清晰，我们可以很轻器地找到自己需要设置的入口位置。 项目功能接下来的部分，我们将分别介绍项目模板中支持的各标签页功能具有的特性，专业版包含需求、迭代、故事墙、缺陷、报表、文档等6个核心应用，还支持通过移动端管理工作。在这里，我们选择进行需求、迭代和看板的基础介绍，同时，由于文档在前面已经有所介绍，加上相对较为简单，便也不做阐述，但是文档始终还是比较关键的部分。 需求在TAPD中，产品需求被称为“User Story”，或简称为Story，是从用户的角度来描述的独立功能点。TAPD支持需求的创建、层级划分、分类、导入/导出、过滤、分析与统计，主要应用于需求的规范创建、backlog视图的生成与划分、工作流的状态管理，在这里，我们仅仅对最基础的创建、层级划分、以及工作流管理进行介绍。 创建需求 通过创建需求按钮，我们可以进行需求的快速创建，同时，可以根据需求模板进行规范的设置 层级划分TAPD支持需求的多层结构管理，对于规模较大的需求，可以使用子需求的创建进行划分，从而细化需求结构。 工作流管理TAPD支持需求的生命周期流程的定制，这样不同的项目需求可以有不同的生命周期流程，通过这个流程驱动，达到研发过程中不同角色成员协作完成Story的研发生命周期管理。 当前处理人进入需求的查看页面，在需求状态流转部分，用户可以选择下一个状态进行流转，并补充流转处理意见，从而完成需求生命周期的当前节点控制。 迭代迭代是一个固定的时间段的开发计划，每个迭代将补充项目产品的某些特性。项目通过迭代划分与发布，可以让产品开发更加敏捷。 TAPD支持将需求，缺陷，任务纳入迭代，除此之外，迭代功能还支持分配成员任务，进行任务的跟踪，以及打印迭代内容卡片这种额外的特性。在此，基础的迭代创建、需求添加、工作划分成为我们主要介绍的部分 创建迭代 需求规划如果需求下有任务，那么规划需求到迭代的同时，需求下的任务自动被规划到迭代。使用拖拽或勾选添加的方式即可将需求划分入某次迭代。 我们要注意，对于大型的需求（有众多子需求），TAPD不允许将父需求规划到迭代，这是因为在项目管理的过程中，过大规模的需求并不能保证能够在一个迭代期完成，单个迭代期应该完成的应该是一些小需求，相对来说这样设计才符合正确的项目规划逻辑。 工作划分在迭代管理的过程中，我们已经划分了需求，此时，作为项目管理者，我们需要做的就是将需求落实到负责人身上，保证每个任务的归属，这时候需要用到工作规划的功能。 对于迭代内的需求，我们可以进行处理人和工时的设定，并以此作为迭代安排的目的计划方案。 看板在TAPD 看板中，一个工作项代表着一项的任务，你可以通过回车快速的创建多条任务，这就像工作中的白板一样简单。创建看板的方式有很多了，除了TAPD之外，github看板的创建也是十分方便，但是既然是介绍TAPD，就不多叙述对github看板的介绍了 看板最主要的功能是使用小卡片的形式表示每一项任务，再将小卡片绘制到面板上，最终形成一面“任务墙”，这个任务墙就是看板。为了让任务的进度更加清晰，看板中的任务卡片还应该具有标注为已完成或未完成的功能，由此我们便可以快速直观地掌握当前任务的进行状态了。 创建看板很显然，看板中每一项任务都在不同的分类列下，我们可以通过创建新的列和任务进行看板的自助规划 关闭任务看板中的任务通常使用checkbox的形式，关闭自然也是直接勾选即可。 由此，我们便完成了对TAPD初级使用的分析，上面的介绍相对来说都只能满足基础的计划需求，感兴趣的各位可以查看TAPD的官方帮助文档，写得十分详细了，本文中的图片素材就有一大部分是来自官方的帮助文档。]]></content>
      <categories>
        <category>产品设计</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级简单易懂的Vuex入门使用指南]]></title>
    <url>%2F2019%2F06%2F27%2Fvuex%2F</url>
    <content type="text"><![CDATA[一、为什么使用Vuex当我们进行前端开发时，不可避免要与页面中的数据打交道，而在VUE框架中，我们都知道当在单个页面操作数据时，最基础的是使用data()方法中的返回数据，这部分数据可以在页面中直接获得，通过v-bind响应式在页面中渲染出来。 但是当我们需要在多个页面间获取组件状态进行数据交互的时候，data中返回出来的数据进行传递的过程显然不是很方便。这时候，Vuex就是一个帮助我们进行数据状态管理的有效的工具了。 Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension ，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 二、Vuex基础使用1. StoreVuex应用的核心是store(仓库)，store是一个包含着组件状态信息的容器，当store中的状态发生变化时，相应的组件也会在同时得到高效的更新。 对于一个最简单的store来说，我们可以用下面的方法进行创建 123456789101112const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 我们可以看到store中包含两个部分，一个是state，state可以理解为我们存储起来的状态对象，另一个是mutation，mutation是一种修改state的方法，后面会提到。 2. State前面说到，state中保存的数据就是我们存储起来的内容，从上面store的声明中也可以看出来数据是用键值对{count：0}的形式保存在store仓库中的，观察结构结构我们也可以发现，获取state的方法也很简单，通过store.state就可以直接获取到state中所有的状态对象了。 但是如何在vue组件中展示state状态呢？ （1） 获取state状态由于vuex的状态存储是响应式的，从store中读取状态最简单的方法就是在计算属性中返回我们需要的状态 1234computed: &#123; count () &#123; return store.state.count &#125; } 但是，这种模式导致组件依赖全局状态单例，简单来说，就是每次需要获取state中的数据时都要进行导入store仓库的工作。 （2）解决重复导入问题为了解决上述重复导入的问题，vuex提供了另一种机制，将状态从根组件“注入”到每一个子组件中（使用Vue.use(Vuex)方法） 1234567891011const app = new Vue(&#123; el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 此时，所有的子组件都能够通过this.$store访问到这个store实例，从而获取到store中的state。 这时候，虽然可以获取到store了，但是出现了新的问题，当我们需要很多store的state中的数据时，重复使用计算属性中的函数返回方法显得十分复杂和冗余，那么这个应该怎么解决呢？ （3）mapState辅助函数减少计算属性编写的复杂度当然也是有办法的，mapState辅助函数可以帮助我们生成计算属性，大大降低了我们编写函数的复杂度。 123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &apos;vuex&apos; export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 在文件中首先引入vuex中的mapState方法，然后在computed的部分使用mapstate进行数据的获取。使用state=&gt;state.count的方法修剪函数形式，使得代码更加简练，同时，单独传递字符串参数的形式也是等同的，我们可以根据自己的需要自行选择。 在这里，我们提到一种更简练的方法，就是不需要冒号前面的值进行变量名的声明，而是直接传递字符串参数完成映射（如下面的形式），但是这种形式个人不是很推荐，就感觉看起来不规格（？），所以我就不多描述 1234computed: mapState([ // 映射 this.count 为 store.state.count &apos;count&apos;&#125;) 回到开始的话题，其实从上面的示例中我们也可以发现，如果需要使用this获取到vue文件中本身的状态，使用mapState显得不是很方便，仍旧需要常规函数的写法。 （4）对象展开运算符mapState会返回一个对象，当我们需要将这个返回的对象和局部计算属性混合使用时，我们就需要工具函数将多个对象合并为一个，使得我们可以将最终的对象传递给computed属性，同时简化写法 1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; 3. Mutation说完了state的获取，这时候我们下一步一定要学习的就是怎么对store中state进行修改。首先，Store中的state是不能被我们直接更改的，想要更改唯一的方法就是显示提交(commit)，也就是使用mutation。 （1） mutation基础每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)，这个回调函数就是我们实际进行state修改的地方。它接受state作为第一个参数，显然，state中的所有数据都可以在回调函数进行修改 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) （2）commit方法mutation的格式我们理解了，那我们应该怎么使用这个回调函数呢？直接掉用吗？ 答案当然是不是。 我们不可以直接调用handler，handler可以理解为当触发了一个事件类型为increment的mutation时，回调函数中的事件就会发生，这个触发的过程就是commit方法。 对于上面的increment函数，我们可以使用下面的语句在vue中进行触发 1store.commit(&apos;increment&apos;) （3）向mutation回调函数中传递参数想要修改数据，传递新的数据给回调函数就是我们下一步思考的了，这个新数据我们称之为mutation的载荷(payload) 12345mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125; 1store.commit(&apos;increment&apos;, 10) 在绝大多数情况下，载荷应该是一个对象，在实际应用中，如果想要传递多个参数，通常我们会选择将这些数据封装到一个对象（如json对象）中，再将这个对象作为荷载传递给相应的回调函数 （4） mapMutations辅助函数不用多说可能大家也能看出来，这个和mapState是一个作用，都是便于在vue文件中引入store中的state和mutation，使用方法其实也是一样的，区别只是在于由于mutation的主要工作内容是其中的回调函数，所以它的获取不需要使用计算属性，而是使用method即可，这里就不过多阐述 12345678910111213141516import &#123; mapMutations &#125; from &apos;vuex&apos; export default &#123; // ... methods: &#123; ...mapMutations([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)` // `mapMutations` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)` ]), ...mapMutations(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.commit(&apos;increment&apos;)` &#125;) &#125;&#125; 4. ActionAction和mutation是类似的，主要的区别在于action可以处理系统中的异步回调方法，而mutation只能是同步的 （1）Action与mutationAction函数接受一个与store实例具有相同方法和属性的context对象，所以在action中我们可以使用commit进行一个mutation的提交。 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit(&apos;increment&apos;) &#125;&#125; 这一点之所以被我放在action介绍的第一点，是因为这种在action作为异步调用方法，在其中使用commit方法进行state修改的写法通常被我们用来将api调用后获取到的数据与当前state进行交互。例如，将从服务器获取到的某数据赋值给state中的某变量。 多数情况下，我们在action中进行api的调用（如get方法），并在对应api调用的回调中将获取到的数据使用commit方法提交给mutation以便于组件状态state的修改 （2）action的使用action与mutation写法类似，调用方法也是类似的，我们都需要使用一种特殊的触发方法进行action中的调用，而这次不应该使用commit，而是使用dispatch分发 1store.dispatch(&apos;increment&apos;) 同理，dispatch也同样支持载荷的方式，具体方法与mutation完全一样，我就不过多赘述 1store.dispatch(&apos;increment&apos;, 10) （3）mapAction赋值函数很好，写到这感觉道理大家应该都懂，我也就不多说，直接上代码示例 12345678910111213141516import &#123; mapActions &#125; from &apos;vuex&apos; export default &#123; // ... methods: &#123; ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions(&#123; add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` &#125;) &#125;&#125; （4） 异步方法异步就会出现问题：action什么时候结束？想要等到结束之后再进行某种行为应该怎么办？稍微熟悉前端的同学就应该知道，对于结束后的处理，我们都是使用then方法的，action也不例外，使用下面的方法就可以 123store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123; // ...&#125;) 而这种方法的前提自然也就是要把需要的数据return出来，dispatch可以处理被触发的action的处理函数返回的promise，而且dispatch仍旧返回promise，action方法的写法如下 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&apos;someMutation&apos;) resolve() &#125;, 1000) &#125;) &#125;&#125; 此时在另外一个action中我们也可以进行如下的操作actions: { 1234567// ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch(&apos;actionA&apos;).then(() =&gt; &#123; commit(&apos;someOtherMutation&apos;) &#125;) &#125;&#125; 涉及async/await的更复杂的组合也可以 123456789actions: &#123; async actionA (&#123; commit &#125;) &#123; commit(&apos;gotData&apos;, await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch(&apos;actionA&apos;) // 等待 actionA 完成 commit(&apos;gotOtherData&apos;, await getOtherData()) &#125;&#125; 5. Gettergetter主要是用来获取state数据的，有计算属性在这个我实在是很少用到，感兴趣的同学可以去查看官方文档，就不说啦 6. modules学会使用vuex的store、state、action、commit，基础的入门就已经完成啦，而modules的模块化也仅仅是指在一个store文件中引入其他store，一个import就做到了！ 额外需要注意的可能就是辅助函数可以新增一个参数表示快捷的访问子store的内容（事实上也不是必须的），感兴趣的大家自己学习就行啦~ 三、Vuex使用中需要注意的事（1）Vuex是好用的模式，但是并不意味着所有数据都要使用vuex进行保存，滥用vuex造成代码冗长和不直观可是一点性价比都没有的，这也是单页面应用并不推荐使用vuex的原因。我们要根据代码环境判断是否有必要使用vuex保存某个状态数据。 （2）Mutation以及action文件在编写的过程中，我们通常使用常量代替其事件类型，比如下面的表示方式，很像是给文件添加了一个目录，这样的好处是代码的合作者可以很清晰地总结mutation文件中声明的所有事件类型，我们自己在使用的时候也是更加方便的 12345export const SOME_MUTATION = &apos;SOME_MUTATION&apos; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; （3）Vuex中的状态是响应式的，但是对于数组的响应过程由于DOM的渲染，只对长度敏感，也就是说，对于数组的状态，vuex只能对长度变化作出反应，并进行增加或截取，具体的数据内容是获取不到的，想要渲染的话要使用Vue.set方法（事实上我还是不行，等待大佬解答） 最后学习和使用vue做好前端开发是个说快很快说慢也很慢的过程，共勉。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以QQ为例解读尼尔森十大交互设计原则]]></title>
    <url>%2F2019%2F06%2F26%2Fproduction%2F</url>
    <content type="text"><![CDATA[作为一个不合格的产品经理，赶紧积累知识才是最重要滴 设计原则一：状态可见原则状态可见原则（Visibility of system status）顾名思义，也就是说使用产品的用户在任何时刻都应该知道自己现在处在什么状态、自己刚刚进行了什么样的操作、自己将要完成什么样的操作等等，只有用户知晓当前其所处的状态是什么，他才能清晰地感知产品的逻辑结构，才能更加轻松容易地上手产品的使用。 对于状态可见原则，一般情况下实现的原则是在用户的操作过程中给予适当的提示。在QQ中我们经常使用的下拉刷新功能就体现出了状态可见的设计原则，刷新前中后显示就是对用户的一种状态提示，可以让用户清楚地知道自己当前的刷新操作已经成功。最下方标签的突出显示也是是一种最常见的对于当前状态的提醒，消息位置的图标是蓝色而其他标签的图标颜色是灰色，这也暗示用户当前的状态为查看消息而非位于其他三个标签下。 由此看来，其实状态可见原则在产品设计中似乎是随处可见，如果产品设计没有遵循状态可见原则，那么很容易让用户在使用产品的过程中产生困惑从而生发出不好的情绪，那么这个产品自然也就失败了。 设计原则二：环境贴切原则环境贴切原则（Match between system and the real world）是指系统的文字、语言等设计应该符合用户的认知，向用户比较熟悉的概念贴近，这样的设计才便于用户理解与使用。 以qq的联系人内公众号显示为例，显示公众号的时候我们会发现当前的页面排版与手机通讯录中的设计是基本相同的，而这时候大家有没有联想到，上图中消息页面的消息通知，其实与我们手机系统中的来电记录也是基本相同的。这种设计其实就是以用户日常使用习惯作为参照，遵循贴切原则产生的产物（虽然大家现在都不怎么打电话了）。 这样设计出来的产品容易引起用户的联想与思考，从而为其理解产品设计理念与功能产生潜在的暗示与促进。 设计原则三：用户可控原则用户可控（User control and freedom）是指当用户可能产生某些错误操作或者时，其具有退出或者撤回的余地。当对于用户可控性进行设计与把控时，用户的使用体验与安全感会大大提高，从而引起其内心对产品对喜爱甚至达到推广的作用。 最常见的自然就是消息撤回功能了，我们都知道，qq后期有的一个功能就是消息的撤回（目前支持的是发送两分钟之内的消息可以撤回），再后来除了撤回以外qq又支持了对于撤回消息的再编辑，这都是根据用户可控原则进行的设计与优化。 设计原则四：一致性原则一致性原则就是需要产品帮助用户培养出一套产品使用习惯，无论是界面的布局、素材的样式又或是文字的风格，在同一个软件产品中，均应该保持其一致性，不仅有利于产品设计逻辑的清晰，更是让用户在使用过程中可以使用简单的思维进行复杂的操作。想要设计出规格的产品，一致性是必不可少的，身为产品经理更是应该高标准要求自己，当产品经理对于产品的规划本身具有逻辑性时，一致性原则将会是无意识遵守的。 qq中一致性原则随处可见，其实不仅是qq，市面上任何一款优秀的软件对于一致性都是有高标准要求的。下图中十分显而易见的就是布局的一致性（不同的页面使用相同的布局）、颜色的一致性（以蓝色为主调）、操作习惯的一致性（右上角进行统一的额外设置），图标的一致性（头像均使用圆形图片表示）等等。 图标的一致性在第二张图体现得更加明显，三张图分别为聊天界面、个人展示界面、看点资讯界面的截图，返回按钮统一放置在左上角且完全使用相同的箭头图标而非频繁更改返回图标样式。这都是一致性的体现 设计原则五：防错原则防错原则顾名思义就是防止用户发生某种错误从而造成不可挽回的损失，通常是指在某种错误操作发生之前，就进行某种提示降低用户犯错的几率。防错原则的用途，第一是保护用户的利益不受意外损失，第二是保证用户的使用体验与情绪，第三自然就是一份免责金牌啦。 防错原则在具有支付与交易功能app中还是比较常见的，如闲鱼、淘宝等app在信息中心含有敏感字段时对用户发送防诈骗提醒，qq、微信等在转账前做出明显的警示等。 设计原则六：易取原则易取原则是指用户对于页面内的交互应尽可能明晰，通过把组件、按钮及选项可见化，来降低用户的记忆负荷。用户不需要记住各个对话框中的信息。软件的使用指南应该是可见的，且在合适的时候可以再次查看。 举个最简单的例子其实就是软件更新时，大多数app都会产生遮罩的新功能指引，这就是一种易取原则的体现。同时，qq这种使用提示红点指引用户一步步查看新版本信息与功能设置的设计也是易取原则的一种 设计原则七：灵活高效原则灵活高效原则也很简单，即是产品的设计应该尽可能使用提高用户使用效率的方法，同时允许根据不同的适用人群进行灵活的设置。 qq中最明显的设计应该是对于动态页关注内容的自定义设置，用户可以根据自己的访问频率自定义想要查看的动态分类，从而满足灵活性和高效的需求。 设计原则九：容错原则容错原则相信开发的大佬们都不陌生，也就是说，当系统运行产生一些小问题的时候，不应崩溃而是继续运行并且做出相应的反馈，具有容错性质的系统最少见到的用户的投诉就是“我刚才明明成功了为什么没反应”。好的容错处理不仅仅需要开发人员做出思考，更多的，如果产品经理能够在策划阶段就给出一些容错机制设定，这效率是事半功倍的。但是，产品负责人们根据目前意外产生的错误进行妥当的应急设置与处理也是十分重要的。 除此之外，好的容错处理不管要提醒用户出现了什么错误，尽可能给出最高效的解决方法也是必要的。 qq中的容错处理主要还是体现在网络连接上，相信大家一定有过断网报错的经历，qq给出的提醒就是需要用户检查网络连接，言简意赅，提示明确，就不过多赘述。 设计原则十：人性化帮助原则人性化帮助不必多说，自然是最大程度，最小影响的前提下为用户提供帮助文档或者直接的帮助，这对于提升用户好感，树立产品形象是一件非常重要的事。 qq的帮助界面不用多说，前面有提过，相对来说qq的帮助界面比较好的达到了最大程度最小影响的原则，但是由于我个人使用过程中没有养成个人中心需要在左上角打开这个行为，emmm从此感觉个人中心所有的设计都不太好 总结ok以上就是尼尔森十大交互设计原则的解析，感谢优设网前人的解读，感慨颇深，于是添加了自己的想法之后分享出来，望共勉。]]></content>
      <categories>
        <category>产品设计</category>
      </categories>
      <tags>
        <tag>交互设计</tag>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形式语言与自动机]]></title>
    <url>%2F2019%2F05%2F15%2FNLP5%2F</url>
    <content type="text"><![CDATA[基本概念 树：一个连通的无回路的无向图称之为树（或自由树），如果树中有一个节点被特别的标记，则这棵树被称之为根树，这个被特别标记的节点为根节点 字符串：字符的有限集合 长度：字符个数 连接：把y的各个符号写在x后面则为字符串x与y的连接，记作xy 次方：x的n次方表示n个字符串x连接 乘积：AB为字符串的集合，则AB={ xy | x∈A, y∈B} 闭包：V^* = V^0 ∪ V^1…… 正则表达式 表述语言的三种途径]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>RE</tag>
        <tag>FSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 4 -- Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F05%2F14%2Fleetcode4-1%2F</url>
    <content type="text"><![CDATA[题目重述There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. 两个有序的数组nums1和nums2，其大小分别为m和n。请找到两个数组排序后的中位数，总运行时间复杂度应为O（log（m + n））。您可以假设nums1和nums2不能都为空。 Example1： 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example2： 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解题思路这道题目比较简单，下意识的想法就是使用归并的方法将两个有序的数组进行排序即可很方便地找到中位数，即新建一个结果数组，依次比较两个数组中的最小值，将更小的值放入结果数组中，一共需要比较m+n-1次。 而由于我们需要得到的结果局哟特殊性——是序列中间的数字，也就是说，在上述归并过程中，我们并不需要得到完整的结果队列，只需要找到结果队列的前(m+n)/2个数据就能够找到中位数，同时，我们也自然地想到，我们并没有必要创建一个数组来存储小于中位数，只需要在前(m+n)/2次判断中找到最大值即可。这时，问题已经被简化为进行(m+n)/2次（实际需要+1）比较得到结果的过程了。 而此时又出现新的问题：当m+n为奇数时，中位数为合并后的序列的第(m+n)/2+1个值，而当m+n为偶数时，则是第(m+n)/2和第(m+n)/2+1个值的平均数。此时我们可以发现，第(m+n)/2和(m+n)/2+1都可能是我们关注的值，而对于这两个数据，我们只需要进行(m+n)/2+1次比较，并记录每次比较结果next及其前一次比较结果before即可，最后根据m+n的奇偶性决定最终结果应该是next还是(next+before)/2。 当然我们还要注意，最终的结果应该是double类型。 代码编写123456789101112131415161718192021222324252627282930313233class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totallength = nums1.size() + nums2.size(); int i = 0, j = 0, curr = 0, before = 0, next = 0; while(curr &lt; totallength/2+1)&#123; before = next; if(i == nums1.size())&#123; next = nums2[j]; j++; &#125; else if (j == nums2.size())&#123; next = nums1[i]; i++; &#125; else if(nums1[i] &lt; nums2[j] )&#123; next = nums1[i]; i++; &#125; else&#123; next = nums2[j]; j++; &#125; curr++; &#125; if(totallength % 2 == 1)&#123; return next; &#125; else&#123; return double(before+next)/2; &#125; &#125;&#125;; 代码见github 运行结果 感觉自己的方法很常规，不是很快，如果有大佬做得更快希望不吝赐教~]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UMLet建模]]></title>
    <url>%2F2019%2F04%2F29%2FUMLet%E5%BB%BA%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[1. 领域建模1.1 Make Reservation 1.2 Payment 1.3 表结构使用mysql进行了数据建模，数据建模的过程发现，其实很多属性都是由其他表中的信息计算得到的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146-- MySQL Script generated by MySQL Workbench-- Wed May 1 18:00:34 2019-- Model: New Model Version: 1.0-- MySQL Workbench Forward EngineeringSET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&apos;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&apos;;-- ------------------------------------------------------- Schema mydb-- ------------------------------------------------------- ------------------------------------------------------- Schema mydb-- -----------------------------------------------------CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 ;USE `mydb` ;-- ------------------------------------------------------- Table `mydb`.`Hotel`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Hotel` ( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(45) NOT NULL, `region` VARCHAR(45) NOT NULL, `address` VARCHAR(45) NOT NULL, `star` INT NOT NULL, PRIMARY KEY (`id`))ENGINE = InnoDB;-- ------------------------------------------------------- Table `mydb`.`Room`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Room` ( `room_id` INT UNSIGNED NOT NULL DEFAULT 1, `hotel_id` INT NULL, `room_type` VARCHAR(45) NULL, `room_number` INT NULL, `room_status` INT NULL, `price` INT NULL, PRIMARY KEY (`room_id`), INDEX `rtoh_idx` (`hotel_id` ASC) VISIBLE, CONSTRAINT `rtoh` FOREIGN KEY (`hotel_id`) REFERENCES `mydb`.`Hotel` (`id`) ON DELETE CASCADE ON UPDATE CASCADE)ENGINE = InnoDB;-- ------------------------------------------------------- Table `mydb`.`Visitor`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Visitor` ( `userID` INT NOT NULL AUTO_INCREMENT, `username` VARCHAR(45) NOT NULL, `password` VARCHAR(45) NOT NULL, `full_name` VARCHAR(45) NULL, `ID_number` VARCHAR(45) NULL, `address` VARCHAR(45) NULL, `phone_number` VARCHAR(45) NULL, `credit_card` VARCHAR(45) NULL, PRIMARY KEY (`userID`), UNIQUE INDEX `username_UNIQUE` (`username` ASC) VISIBLE)ENGINE = InnoDB;-- ------------------------------------------------------- Table `mydb`.`Reservation`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Reservation` ( `reserID` INT NOT NULL AUTO_INCREMENT, `userID` INT NOT NULL, `hotelID` INT NOT NULL, `room_type` VARCHAR(45) NOT NULL, `startdate` DATE NULL, `enddate` DATE NULL, `total_price` VARCHAR(45) NULL, `full_name` VARCHAR(45) NOT NULL, `ID_number` VARCHAR(45) NOT NULL, `address` VARCHAR(45) NOT NULL, PRIMARY KEY (`reserID`), INDEX `retov_idx` (`userID` ASC) VISIBLE, INDEX `retoh_idx` (`hotelID` ASC) VISIBLE, CONSTRAINT `retov` FOREIGN KEY (`userID`) REFERENCES `mydb`.`Visitor` (`userID`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `retoh` FOREIGN KEY (`hotelID`) REFERENCES `mydb`.`Hotel` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDB;-- ------------------------------------------------------- Table `mydb`.`Creditcard`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Creditcard` ( `idCreditcard` INT NOT NULL AUTO_INCREMENT, `number` VARCHAR(45) NULL, `password` VARCHAR(45) NULL, `owner` INT NULL, PRIMARY KEY (`idCreditcard`), INDEX `ctov_idx` (`owner` ASC) VISIBLE, CONSTRAINT `ctov` FOREIGN KEY (`owner`) REFERENCES `mydb`.`Visitor` (`userID`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDB;-- ------------------------------------------------------- Table `mydb`.`Payment`-- -----------------------------------------------------CREATE TABLE IF NOT EXISTS `mydb`.`Payment` ( `idPayment` INT NOT NULL AUTO_INCREMENT, `creater` INT NULL, `createtime` DATETIME NULL, `lasttime` DATETIME NULL, `price` INT NULL, `creditcard` INT NULL, PRIMARY KEY (`idPayment`), INDEX `ptov_idx` (`creditcard` ASC) VISIBLE, INDEX `ptov_idx1` (`creater` ASC) VISIBLE, CONSTRAINT `ptoc` FOREIGN KEY (`creditcard`) REFERENCES `mydb`.`Creditcard` (`idCreditcard`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `ptov` FOREIGN KEY (`creater`) REFERENCES `mydb`.`Visitor` (`userID`) ON DELETE NO ACTION ON UPDATE NO ACTION)ENGINE = InnoDB;SET SQL_MODE=@OLD_SQL_MODE;SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS; 2. Reservation生命周期建模整个状态过程如下： 首先进行旅馆的搜索：分别要进行城市、起始时间、结束时间的输入，当没有找到结果时，需要在地图上进行搜索，这都是在第一个搜索旅馆状态中的子状态 搜索结束后，要对搜索结果进行显示，也就是showhotel状态，此时如果进行sort操作，还是位于当前show hotel状态，不过是排序后的结果 选择目标旅馆之后可以查看旅馆详情，此时，如果认为不满意，可以返回到show hotel状态 如果认为满意，可以进行预订，选择房间型号、并提供正确的姓名和地址（默认显示用户自己的全名和地址），如果信息未填写完即取消，可以返回查看详情页面 确定预订之后进行支付，支付时需要提供有效的银行卡号以及支付密码 如果支付成功，则等待订单完成，如果支付失败即取消，则结束 如果订单成功完成，或者临时被取消，那么都进入结束状态]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_Containers]]></title>
    <url>%2F2019%2F04%2F17%2FC-Containers%2F</url>
    <content type="text"><![CDATA[C++容器是一种可以保存其他数据类型指针的对象类型，其空间可扩展性也使得其相对于数据来说具有很大的优势。 本文对C++容器的使用进行了总结说明 Reference：C++ array简介std::array是一种定长的序列容器，其中元素遵循严格的线性排序。与其他容器不同，array是固定大小的封装类型，所以不能进行扩展或者缩小，同时，交换两个array的行为是一种线性的操作，相对来说是十分低效的。 所以array具有如下三个特点：序列化（内部元素严格线性存储，需要按照位置访问）、连续存储（array的内存空间是连续分配的，可以使用指针偏移访问相应的元素）、大小固定（array使用隐式构造函数与析构函数进行控件的静态分配，其大小是编译时确定的常量，没有内存和时间上的开销） 声明方法12std::array&lt;int, size&gt; arrayname；std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; 遍历方法1for ( value_type&amp; x : myarray) 成员函数 table th:nth-of-type(5){ width: 36%; }, table th:nth-of-type(3){ width: 32%; } table th:nth-of-type(1){ width: 9%; } table th:nth-of-type(2){ width: 15%; } table th:nth-of-type(4){ width: 8%; } 功能 方法 用法 类型 备注 iterator begin 获取顺序iterator第一个元素 public end 获取顺序iterator最后一个元素 public rbegin 获取倒序iterator第一个元素 public rend 获取倒序iterator最后一个元素 public cbegin 同begin public const类型，可以访问不可修改 cend 同end public const类型，可以访问不可修改 crbegin 同rbegin public const类型，可以访问不可修改 crend 同rend public const类型，可以访问不可修改 capacity size 返回容量 public sizeof为容量*类型长度 max_size 和size一样 public empty 容量是否为0 bool element access operator[] 返回指定位置的元素 public （1）可以直接访问，也可以对返回的元素进行修改（2）超出返回out-of -range异常 at (pos ) 返回指定位置的元素 public （1）可以直接访问，也可以对返回的元素进行修改（2）超出返回out-of -range异常 front ( ) 返回第一个元素 public （1）与begin不同，返回直接引用；（2）如果对空容器使用该方法，会产生undefined异常（3）可以对返回的对象进行修改 back ( ) 返回最后一个元素 public （1）与end不同，返回直接引用；（2）如果对空容器使用该方法，会产生undefined异常（3）可以对返回的对象进行修改 data() 返回对象头部指针 public modifiers fill（value_type&amp; val） array中全部元素设为val public fill_n (OutputIterator first, Size n, const T&amp; val) array1.swap(array2) 交换两个array public （1）两个array大小和类型相同(2)swap是一种线性的操作 non-member function overloads get(array) 访问pos位置的值 public （1）是对元组get方法的重载（2）不会抛出异常 relational operators(array) 比较操作 bool （1）比相等时，要内容和容量完全相同（2）比大小时，元素内容依次比较，如果出现不同直接返回大小（类似字典序） non-menber class tuple_element public 静态元组形式访问元素 tuple_size public 静态元组形式访问大小 &lt;–持续更新中–&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[make_reservation]]></title>
    <url>%2F2019%2F04%2F12%2Fmake-reservation%2F</url>
    <content type="text"><![CDATA[设计Asg-RH旅馆预定系统用例图设计预定酒店活动图设计快递柜系统业务场景泳道图设计快递柜系统用例图 Asg-RHAsg用例图用户交互主要包括搜索旅馆、预定旅馆、购物车操作以及支付，对于这四种交互分别进行用例的完善和关联关系的设计： 搜索旅馆：搜索时需要输入城市、入住日期、离店日期三种必要信息，所以将这三种情况使用include关系与搜索用例关联，同时搜索结果支持排序，以及如果没有搜索结果则查看推荐，于是这两种用例使用extend关系关联：其中，排序功能支持不同的四种元素筛选，所以使用泛化关系丰富排序用例 预定旅馆：预定时必须的流程有搜索、选择旅店、选择房型以及确定预定，其中，选择旅店时需要支持查看详情，确认预定时需要完善全名和地址两种客户信息 购物车操作：购物车支持添加、移出、检查三种操作，其中，用户添加购物车时，首先需要完善个人信息 支付：支付过程中，用户必须进行的操作有选择支付账户，填写必要信息，其中，选择支付账户可以调用外部接口 Make reservation 活动图 快递系统泳道图业务1整体流程：快递员登录-&gt;存放快递-&gt;短信平台发送短信-&gt;收件人凭短信信息取件 业务2整体流程：快递员扫描二维码登录-&gt;公司认证身份-&gt;快递员扫描单号-&gt;存放快递-&gt;快递公司发送短信-&gt;收件人凭短信信息取件 业务3整体流程：快递员扫描二维码登录-&gt;公司认证身份-&gt;快递员扫描单号-&gt;存放快递-&gt;判断用户是否关注公众号-&gt;(快递公司/公众号)发送短信-&gt;收件人凭短信信息取件 用例图]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用例建模-绘制用例图]]></title>
    <url>%2F2019%2F04%2F08%2Fusecase%2F</url>
    <content type="text"><![CDATA[对于用例以及用例图的概念给出了定义 针对票务系统的三个软件进行了用例建模 对详细系统用例图进行了分析 知识点 用例 用例是系统针对请求进行响应的行为的描述，可以说，用例是基于某种或者多种场景下的系统与用户的交互行为，简单来说，可以理解为用例就是某用户使用系统时能够进行的某操作的描述。 在软件工程中，用例表示一种通过用户的使用场景来获取需求的技术，一般由软件开发者和用户共同编写。 用例和场景的关系？什么是主场景或happy path？ （1）场景：是客户与系统之间的交互行为。场景是用例的实例，一用例是场景的集合 （2） 主场景：是场景中最主要的交互，一般是经常出现的，用户最常用的场景流程。 （3）happy path：在软件或信息建模的环境中，happy path是一种默认没有异常情况而能流畅完成业务的操作路径 用例的形式 （1）Brief（high level）：通常是主场景的总结，在早期分析需求的过程中，breif形式可以帮助开发者和客户快速了解软件系统的主题和应用范围等信息，可以快速创建 （2） Casual（简便格式）：非正式的段落格式；覆盖多个场景的几个段落，与breif近似，在早期需求分析过程中，有助于快速了解主题和范围 （3） Fully：用例中所有的步骤和变化都写得很详细，包括前置条件等应用环境。所有的用户样例都已经定制出初步版本后，优先级更高的用例会被详细编写。 对于复杂业务，为什么编制完整用例非常难 对于复杂业务来说，用例的应用场景十分复杂，需要考虑的因素也有很多。而对于前期的需求分析过程，想要在用力建模额过程中就分析出所有的应用场景是理想的情况，实际建模的过程中，一些被遗漏的场景通常会在后期实现的过程中被发现，这时才能继而编写完整的用例。 同时，对于用例建模的过程，如果一开始就建立出较为复杂度较高的用例，可读性也并不是很强。 什么是用例图 用例图是一种以绘图的方式展现用例场景的表示方法。用例图以用户和用户行为为主，可以体现出用户与系统的交互场景，并使用图形化的方式，形象地展示出系统的边界和使用方法，对于开发者和使用者来说，都可以通过用例图了解系统与用户间可能的交互行为 用例图的基本符号与元素 （1） 参与者（actors）：表示系统中的用户，即与系统交互的对象 （2）用例（use case）：用户与系统的交互行为，可以理解为用户可以使用系统做的事情 （3）包含关系（include）：被指向的用例为发起用例的行为之一 （4）扩展关系（extend）：被指向的用例为发起用例的扩展功能 （5）泛化关系（generalization）：被指向的用例是发起用例的特例之一 （6）关联关系（association）：表示参与者与用例之间的关系 用例图的画法与步骤 （1）确定系统边界 先使用方框画出系统边界并标记系统名称 （2）确定参与者 明确参与者是谁：用户？管理员？设备？只要是使用系统产生交互的对象都是参与者 在系统边界外部使用参与者符号，添加参与者信息 （3）确定用例 明确系统中的用例场景都有什么：确定系统功能，确定用例之后，在系统方框内添加用例符号并标识用例信息 明确参与者与用例之间的交互关系：确定参与者与用例之间的关系之后就可以使用关联关系的符号将两者相连 明确用例之间的关系：明确将用例之间的关系，分别为泛化关系、包含关系、扩展关系，分别用这三种关系的符号连接相应的用例 （4）确定外部接口 外部接口可能是一些API的调用，在系统方框外用其他的方框标识调用的外部api，并使用关联关系符号将接口与调用此接口的用例相连 用例图给利益相关人员与开发者的价值 （1）用例图便于帮助未参与需求设计的开发者更好地理解系统功能，是开发者与产品负责人沟通的桥梁 （2）用例图可以形象地展示系统边界以及系统功能，对于项目工作量的呈现也是十分形象化的 （3）用例图可以帮助开发者梳理项目开发流程与技术要点，便于开发者进行研究学习与开发准备 用例建模 淘票票 大麦网 携程网 用例问题 为什么相似系统的用例图是相似的？ 由于用户对于某一特定目标的的广泛需求是固定的，所以为了满足用户最基本的需要、让系统功能的基础建设较为完善，不同的系统开发团队都会针对这部分最广泛的需求进行功能设计，也就是说这个软件的不同点往往不在用例上，而是在交互设计上，所以，对于展示用例场景的用例图来说，相似系统往往是差不多的。 如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术 使用不同颜色进行标识 如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用 可以使用较为鲜艳的颜色对需要表示的创新点进行标识 使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表 table th:nth-of-type(6){ width: 50%; } ID TITLE IMP EST ITER HOW TO DEMO 1 查看列表 5 2 1 主页查看酒店的简略信息，点击查看酒店详情，包括位置、星级、评价等信息 2 排序 4 3 2 按照好评、价格、距离等排序 3 预定酒店 5 3 3 用户预定酒店后保存预定信息 4 个人信息编辑 5 2 2 包括身份信息，支付信息以及其他信息 5 支付房费 5 1 2 使用支付接口 6 搜索酒店 5 2 1 通过姓名、评价、位置等关键词完成搜索 7 查看地图 3 2 3 在地图上查看酒店位置 8 学习接口技术 3 3 1 学习系统功能api使用方法 9 订单反馈 3 3 3 用户评价订单，评价显示 根据任务3，参考使用用例点估算软件成本，给出项目用例点的估算 用例 事务 计算 原因 UC权重 查看列表 3 2 简单 排序 3 3 简单 预订酒店 4 4 简单 个人信息编辑 3 3 简单 支付房费 2 1 简单 搜索酒店 4 4 简单 查看地图 3 1 框架 简单 学习接口技术 4 4 简单 订单反馈 6 6 平均]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
        <tag>points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nltk]]></title>
    <url>%2F2019%2F03%2F25%2Fnltk%2F</url>
    <content type="text"><![CDATA[ntlk是一个比较常用的用于自然语言处理的python库，在这篇文章中，将会对ntlk的使用进行总结和归纳。 相关代码示例 text = ’Don’t hesitate to ask questions. Be positive‘ 安装：安装使用pip正常安装即可，但是在第一次使用前要利用download命令，并在弹出的下载器中下载相应的文件包，全部下载需要2G左右。下载时要开VPN，否则服务器会没有响应。如果下载还是不成功，可以尝试从github/nltk中下载需要的package并放在默认路径中（APPDATA) 12import nltknltk.download() 测试安装是否成功：导出包中的预置文本从而判断包有没有下载成功 123456from nltk.corpus import brownprint(brown.words())print(len(brown.sents())) # 句子数print(len(brown.words())) # 单词数from nltk.book import * 文本切分成语句：对text进行语句划分，输出为sentence的list 12345678# 方法一from nltk.tokenize import sent_tokenizeprint(sent_tokenize(text))# Out: ["Don't hesitate to ask questions.", 'Be positive.']# 方法二tokenizer=nltk.data.load('tokenizers/punkt/english.pickle') print(tokenizer.tokenize(text))# Out: ["Don't hesitate to ask questions.", 'Be positive.'] 语句分词：对sentence进行划分，最终得到words 1234567891011# 方法一：TreebankWordTokenizer依据Penn Treebank语料库约定，通过分离缩略词来实现划分words=nltk.word_tokenize(text) print(words)# Out: ['Do', "n't", 'hesitate', 'to', 'ask', 'questions', '.', 'Be', 'positive', '.']#方法二：PunctWordTokenizer通过分离标点实现划分，每一个单词都会被保留from nltk.tokenize import WordPunctTokenizer tokenizer=WordPunctTokenizer() words = tokenizer.tokenize(text) print(words# Out: ['Don', "'", 't', 'hesitate', 'to', 'ask', 'questions', '.', 'Be', 'positive', '.']# 其他分词方法# RegexpTokenizer、WhitespaceTokenizer、BlanklineTokenizer 概率分布：nltk.probability.FreqDist 123456789101112fdist = FreqDist(samples) # 创建包含给定样本的频率分布，参数为词的列表 fdist.inc(sample) # 增加样本 fdist['monstrous'] # 计数给定样本出现的次数 fdist.freq('monstrous') # 给定样本的频率 fdist.N() # 样本总数 fdist.keys() # 以频率递减顺序排序的样本链表 for sample in fdist: # 以频率递减的顺序遍历样本 fdist.max() # 数值最大的样本 fdist.tabulate() # 绘制频率分布表 fdist.plot() # 绘制频率分布图 fdist.plot(cumulative=True) # 绘制累积频率分布图 fdist1 &lt; fdist2 # 测试样本在 fdist1 中出现的频率是否小于 fdist2 条件概率分布：nltk.probability.ConditionalFreqDist 123456789cfdist= ConditionalFreqDist(pairs) # 从配对链表中创建条件频率分布 cfdist.conditions() # 将条件按字母排序 cfdist[condition] # 此条件下的频率分布 cfdist[condition][sample] # 此条件下给定样本的频率 cfdist.tabulate() # 为条件频率分布制表 cfdist.tabulate(samples, conditions) # 指定样本和条件限制下制表 cfdist.plot() # 为条件频率分布绘图 cfdist.plot(samples, conditions) # 指定样本和条件限制下绘图 cfdist1 &lt; cfdist2 # 测试样本在 cfdist1 中出现次数是否小于在 cfdist2 中出现次数 文本整体统计分析：nltk.text.Text()类用于对文本进行初级的统计与分析 12345678Text(words) # 对象构造,参数为词的列表 concordance(word, width, lines) # 显示 word 出现的上下文 common_contexts(words) # 显示words出现的相同模式 similar(word) # 显示 word 的相似词 collocations(num, window_size) # 显示最常见的二词搭配 count(word) # word 出现的词数 dispersion_plot(words) # 绘制 words 中文档中出现的位置图 vocab() # 返回文章去重的词典 语料库：nltk.corpus 123456gutenberg # 大约有 36000 本免费电子图书，多是古典作品 webtext # 网络小说、论坛、网络广告等内容 nps_chat # 有上万条聊天消息语料库，即时聊天消息为主 brown # 一个百万词级别的英语电子语料库，这个语料库包含 500 个不同来源的文本，按 文体分类有新闻、社论等 reuters # 路透社语料库，上万篇新闻方档，约有 1 百万字，分 90 个主题，并分为训练集和 测试集两组 inaugural # 演讲语料库，几十个文本，都是总统演说 语料库操作 12345678fileids() # 返回语料库中文件名列表 fileids[categories] # 返回指定类别的文件名列表 raw(fid=[c1,c2]) # 返回指定文件名的文本字符串 raw(catergories=[]) # 返回指定分类的原始文本 sents(fid=[c1,c2]) # 返回指定文件名的语句列表 sents(catergories=[c1,c2]) # 按分类返回语句列表 words(filename) # 返回指定文件名的单词列表 words(catogories=[]) # 返回指定分类的单词列表 提取词干：取出单词中的词缀，得到单词的词根或者词干，搜索引擎大多会使用词干提取来获取词干并将其存储作为索引词 12345678910111213141516# 方法一：在 NLTK 中使用 PorterStemmer 类进行词干import nltk from nltk.stem import PorterStemmer stemmerporter = PorterStemmer() stemmerporter.stem('happiness')# Out: 'happi'# 方法二2：LancasterStemmer 类在 NLTK 中用于实现 Lancaster 词干提取算法import nltk from nltk.stem import LancasterStemmer stemmerlan=LancasterStemmer() stemmerlan.stem('happiness')Out: 'happy'# 方法三# 过使用 RegexpStemmer 类构建词干提取器，通过接受一个字符串，并在找到其匹配的单词使删除该单词的前缀和后缀 词性标注：对单词的词性如名词，动词形容词等属性进行标记，nltk.tag包中包含词性标注器，被TaggerIbase继承 123456789101112# 英文标注通常使用nltk，对中文标注时常使用jieba模块import nltk text1=nltk.word_tokenize("It is a pleasant day today") nltk.pos_tag(text1)# Out: [('It', 'PRP'), ('is', 'VBZ'), ('a', 'DT'), ('pleasant', 'JJ'), ('day', 'NN'), ('today', 'NN')]# jieba标注中文文本seg = jieba.posseg.cut(sentence_words)l = []for j in seg: l.append(j.word) l.append(j.flag)print(l, file=output) 清除标点符号：中英文均可 123456789101112def filter_punctuation(words): new_words = []; illegal_char = string.punctuation + '【·！…（）—：“”？《》、；】' pattern=re.compile('[%s]' % re.escape(illegal_char)) for word in words: new_word = pattern.sub(u'', word) if not new_word == u'': new_words.append(new_word) return new_wordswords_no_punc = filter_punctuation(words) print(words_no_punc)# Out: ['Don', 't', 'hesitate', 'to', 'ask', 'questions', 'Be', 'positive'] 大小写转换 1234print(text.lower()) print(text.upper()) # Out: don't hesitate to ask questions. be positive. # DON'T HESITATE TO ASK QUESTIONS. BE POSITIVE. 处理停止词 1234from nltk.corpus import stopwords stops=set(stopwords.words('english')) words = [word for word in words if word.lower() not in stops]print(words)]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database——sql]]></title>
    <url>%2F2019%2F03%2F24%2Fdatabase%2F</url>
    <content type="text"><![CDATA[对sql语句的基础语法以及一些细节操作进行了总结 语法 检索：SELECT FROM &lt;table_name&gt; WHERE 删除：DELETE FROM &lt;table_name&gt; WHERE 更新：UPDATE &lt;table_name&gt; SET &lt;&gt; END 排序：ORDER BY 分组：GROUP BY HAVING 排序：DESC/ASC 连接： INNER/LEFT/RIGHT JOIN ON inner 是内连接，当两个表的内容都能匹配的时候才形成连接 left是左连接，除了两个表可以匹配的内容以外，table1表中无法形成新连接的部分也会被选取出来 right是右连接，除了两个表可以匹配的内容以外，table2表中无法形成新连接的部分也会被选取出来 用法 命名表头：SELECT as 命名检索结果：（SELECT ……） AS &lt;table_name&gt; COUNT()：计数 COALESCE(element1, element2, ……)：从element1开始检测是否为null，直到遇到非null值便返回，如果全是null最终返回null IF(， , )：如果condition为true，返回第二个参数值，如果为false返回第三个参数值 IFNULL(, )：和coalesce类似 CASE WHEN THEN &lt;&gt; ELSE： DISTINCT：去重 DATEDIFF(date1， date2)：返回两个date之间相差的天数 BETWEEEN AND：包括左右边界的范围，可以对日期字符串操作 &lt;&gt;：不等号 := ：赋值号 逻辑：AND OR]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum matching algorithm]]></title>
    <url>%2F2019%2F03%2F24%2Fmax-match-alg%2F</url>
    <content type="text"><![CDATA[在基于某些规则利用语料库对目标文本进行分词时，会使用最大匹配法（Maximum Matching， MM），也就是在匹配过程中，每次词汇的分割都将当前能够比配到的最长的字符串分割出来，即输入为一行未被划分的文本，输出为按照匹配规则分隔好的词汇。 最大匹配算法分为三个方向，分别是正向最大匹配算法（Forward MM, FMM）、逆向最大匹配算法（Backward MM, BMM）、双向最大匹配算法（Bi-directional MM,） 正向最大匹配算法正向最大匹配算法是指从字符串起始端使用最大匹配算法进行分割。 首先从语料库中找到能够进行匹配的最长字符串长度L，也就是每次分割都要对这个最长长度进行检测。 当当前的文本前L个字符组成的字符串无法与语料库中的成分进行匹配时，就将检测的字符串长度-1，也就是检测前L-1长度的字符串，如果还是不行，就继续-1，如此循环。 此时，我们可以发现，整个算法过程是以能够匹配到的最大长度的字符串开始匹配，然后逐个排除并将目标长度减短1，从而得到最终的正向最大匹配结果。 123456789从第一个字符开始while 还有待检测字符 以理想最长匹配长度进行匹配 if 匹配成功 文本去除已匹配字符串 else if 匹配失败，但仍有减短长度的空间 匹配长度-1，重新匹配 else 将当前字符去除 逆向最大匹配算法逆向最大匹配算法与正向相同，但是起始检测字符不是起始字符，而是结尾字符 123456789从最后一个字符开始while 还有待检测字符 以理想最长匹配长度进行匹配 if 匹配成功 文本去除已匹配字符串 else if 匹配失败，但仍有减短长度的空间 匹配长度-1，重新匹配 else 将当前字符去除 双向最大匹配算法双向最大匹配算法是逆向最大匹配算法与正向最大匹配算法的结合，当正向效果较好时就采用正向效果，当逆向效果较好时便采用逆向效果，通常用分解出来的字符串数目进行效果的检验。]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Encryption Standard]]></title>
    <url>%2F2019%2F03%2F19%2FDES%2F</url>
    <content type="text"><![CDATA[DES简介DES是一种对称密码体制加密算法，明文和密钥均由64位二进制位构成，其中，密钥实际作用位共56位（第8的整数倍的位均为奇偶校验位，使密钥中8个为一组的二进制位组中保证有奇数个1，不发生作用） 目前除了穷举搜索法，还没有发现的攻击DES有效算法，安全性较高。 DES加密流程详解DES加密算法的过程中涉及到很多位数的改变，如32位变为48位，48位编程32位等等，所以理清DES算法最重要的一个点就是要弄明白“什么数据在什么时候发生了什么变化”。 在这份详解中，我将所有的中间数据全用“（名称）位数”的格式来命名，如data_64，来区分不同过程中数据的形式。 1.&lt; 处理明文&gt;将明文data_64通过IP置换操作，转写成新的二进制位串，即IP_64。 转换过程如下，数组元素表示新的IP数据每一位放置哪一个旧data位，如58表示IP第1位为data的第58位，IP第2位为data第50位，以此类推（后文置换变化方法相同） 12345678int IpTrans[64] = &#123;58,50,42,34,26,18,10,2, 60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6, 64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1, 59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5, 63,55,47,39,31,23,15,7&#125;； 2. &lt;分解IP&gt;将IP分为左右两部分L0_32和R0_32,即前32位和后32位 3. &lt;处理密钥&gt;将密钥key64通过PC_1置换操作，转写成新的二进制位串，即newKey56，此时，操作产生的56位密钥newKey，相当于将key去掉8个奇偶校验位后再进行置换得到的新串，PC_1置换表如下（我们可以发现此时的置换表中没有8的倍数位，即等同于将奇偶校验位去掉） 12345678int PC_1[56] = &#123;57,49,41,33,25,17,9, 1,58,50,42,34,26,18, 10,2,59,51,43,35,27, 19,11,3,60,52,44,36, 63,55,47,39,31,23,15, 7,62,54,46,38,30,22, 14,6,61,53,45,37,29, 21,13,5,28,20,12,4&#125;; 4. &lt;分解密钥&gt;如同分解IP一样，将密钥分为左右两部分C0_28和D0_28，不同的是要增加其他操作 （1） C0和D0分别连续进行16次循环向左移位，产生16个新的C和D，并依次记为C1…C16和D1..D16，16次移位数如下 1int left_shift[16] = &#123;1,1,2,2,2,2,2,2, 1,2,2,2,2,2,2,1&#125;; （2）将Cn合并得到DnCn_56后，通过PC_2置换操作得到16个Kn48，即此时由56位变为48位（n≠0） 12345678int PC_2[48] = &#123;14,17,11,24,1,5, 3,28,15,6,21,10, 23,19,12,4,26,8, 16,7,27,20,13,2, 41,52,31,37,47,55, 30,40,51,45,33,48, 44,49,39,56,34,53, 46,42,50,36,29,32&#125; 5. &lt;循环操作&gt;通过如下函数关系，我们对L和R进行16次循环操作 Ln=Rn-1 其中，f函数包括以下三个步骤，异或，缩位，置换 （1）异或：R与K进行异或，我们需要把R（上文IP的右侧）从32位变为48位，此时需要E置换，置换后按位异或 12345678int E[48] = &#123;32,1,2,3,4,5, 4,5,6,7,8,9, 8,9,10,11,12,13, 12,13,14,15,16,17, 16,17,18,19,20,21, 20,21,22,23,24,25, 24,25,26,27,28,29, 28,29,30,31,32,1&#125; （2）缩位：为了产生新的32位R，我们将得到的48位串经过s盒变换转写成32位 -&gt;首先把48位6位一组分成8组，这8组分别匹配8个S盒，每个S盒6位输入后输出4位，S盒内部结构是4行16列的二维数组，数组元素范围为0-15，为最后的4位输出，8组共32位 -&gt;S盒工作方法是：首位与末尾合并表示行，中间四位表示列，在盒子中选择对应的数组元素的二进制表达作为输出 -&gt;如第一组数据是110010，则行数为首位末尾结合的10，列号为中间4位1001，则输出S1盒的table[2][9]的二进制1100 12345678910111213141516171819202122232425262728293031323334353637383940// 使用一维数组的形式代替了二维数组int S1[64] = &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7, 0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8, 4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0, 15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13&#125;;int S2[64] = &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10, 3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5, 0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15, 13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;;int S3[64] = &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8, 13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1, 13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7, 1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;;int S4[64] = &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15, 13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9, 10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4, 3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;;int S5[64] = &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9, 14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6, 4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14, 11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;;int S6[64] = &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11, 10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, 9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6, 4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;;int S7[64] = &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1, 13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6, 1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2, 6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;;int S8[64] = &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7, 1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2, 7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8, 2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;; （3）将上面得到的32位串进行P盒变换，得到新的R，下角标+1 12int P[32] = &#123;16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25&#125;; 6. &lt;逆置换IP&gt;根据上述流程得到L_16和R_16后，我们对其进行逆置换，即初始IP置换的逆置换，得到密文 如我们开始将第58位放置于第1位，那逆置换就是把第1位放回58位 12345678int IP_inTrans[64] = &#123;40,8,48,16,56,24,64,32, 39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30, 37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28, 35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26, 33,1,41, 9,49,17,57,25&#125;; DES加密流程总结 置换明文为IP并分为左右两部分L和R 置换并缩小密钥位数后分为左右两部分C和D 将密钥的左右两部分循环左移得到16个K 利用K、L、R、异或、S盒、P盒得到新的L和R 将L16R16逆置换，得到最后的密文]]></content>
      <categories>
        <category>web-security</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular_Expression]]></title>
    <url>%2F2019%2F03%2F18%2FRegular-Expression%2F</url>
    <content type="text"><![CDATA[正则表达式概念​ 正则表达式是对字符串操作的一种逻辑公式，是用事先定义好的一些特定字符、及这些特定字符的组合，组成一种规则字符串，从而表达一种过滤逻辑。在程序设计中，通常使用正则表达式来检索和替换那些符合某种规则（模式）的文本。 python编译正则表达式使用python编译正则表达式时，需要引入re模块，此时可以使用正则表达式的所有功能1. re.compile(parttern[, flags]) 将正则表达式进行编译，从而使用其所有的功能，返回RegexObject对象 2. re.match(pattern, string, flags=0) 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match就范围none 3. re.search(pattern, string, flags=0) 扫描整个字符串并返回第一个成功的匹配。 4. re.sub(pattern, repl, string, count=0, flags=0) 替换字符串中的匹配项 5. re.compile().findall(string[, pos[, endpos]]) 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表 6. re.split(pattern, string[, maxsplit=0, flags=0]) 按照匹配的子串将字符串分割后返回列表 7. re.compile().match().group() group参数为0时返回得到的结果，否则为第n个子串 参数 描述 备注 pattern 正则表达式 pattern = r’sa{1,2}s’ string 目标字符串 string = r’saas sas ssaads ssas’ flags 匹配模式，如大小写等 repl 替换的字符串 可以为一个函数 count 模式匹配后替换的最大次数 默认0表示替换所有 pos 起始位置 endpos 结束位置 maxsplit 分割次数 默认0为不限制次数 简洁正则表达式 正则表达式 匹配字符 [0-9] 0123456789任意之一 [a-z] 任意小写字母 [A-Z] 人以大写字母 \d 等同于[0-9] \D 等同于[^0-9] \w 等同于[a-z0-9A-Z_],匹配大小写字母数字和下划线 \W 等同于[^a-z0-9A-Z_] \s 任何空白字符，包括空格、制表符、换页符等，[ \f\n\r\t\v] \S 任何非空白字符，[^ \f\n\r\t\v] 正则表达式元字符 元字符 匹配规则 示例 [] 匹配括号中任意一个字符 [adegS] [^] 匹配括号内字符外都能匹配 [^fda] . 匹配任意一个字符，需要匹配该符号时使用\转义 . + 前一个字符重复1次或多次，尽可能贪婪地多匹配 a+ ? 前一个字符出现0次或1次， a? +？ 前一个字符重复1次或多次，将贪婪转为懒惰 fds+?f * 前一个字符重复0次或多次，*？同理 a* {a, b} a&lt;=前一个字符匹配次数&lt;=b；b省略逗号保留表示至少；逗号和b一同省略表示准确数目 a{1,2}s &#124; 逻辑或操作符 a&#124;b - 定义一个区间 a-c \ 对下一个字符取非（通常是转义作用） ^ 匹配字符串的开头 ^a $ 匹配字符串的结束 a$ {\b] 退格字符 \c 匹配一个控制字符 \t 匹配一个制表符 正则表达式修饰符——可选标志 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别匹配 re.M 多行匹配，影响^和$ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符，影响\w \W \b \B re.X 给予灵活的格式，以便将正则表达式写得更加易于理解 python练习题目：在字符串sysu@hotmail.edu.cn中匹配出@hotmail. 示例代码1（错误示例） 123456# 错误使用贪婪匹配，导致输出结果为@hotmail.edu.import rekey = r"sysu@hotmail.edu.cn"p1 = r"@.+\."pattern1 = re.compile(p1)print(partten1.findall(key)) 示例代码2——懒惰匹配12345import rekey = r"sysu@hotmail.edu.cn"p1 = r"@.+?\."pattern1 = re.compile(p1)print(partten1.findall(key)) 示例代码3——非懒惰匹配12345import rekey = r"sysu@hotmail.edu.cn"p1 = r"@[^\.]+\."pattern1 = re.compile(p1)print(partten1.findall(key))]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件项目过程模型与规划]]></title>
    <url>%2F2019%2F03%2F13%2Fsystem-design-hw3%2F</url>
    <content type="text"><![CDATA[瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点 瀑布模型 （1） 优点 ​ a） 瀑布模型的流程符合客观的开发方式 ​ b） 有利于软件开发方法和工具的研究，从而提高了大型软件项目开发的质量和效率。 ​ c） 理论上当前一阶段的工作完成，人们只需要关注后续的部分 （2） 缺点 ​ a）瀑布模型的各个环节前后相连， 开发过程不能逆转，出现调整时代价过大 ​ b）模型要求需求明确，但是往往客户无法给出精确的需求，真正的开发过程也很难完全按照流程进行 ​ c） 软件成品要开发结束才可以拿到，期间很难做出即时的反馈，比较考验客户的耐心，难以及时沟通解决问题 ​ d）开发的不同阶段里，知识技能的需求不同，人员数量要求不同 增量模型 （1） 优点 ​ a）将很大的工作量划分为小的增量，减小了开发者压力 ​ b）每次增量发布都有可操作的产品产出，前一个产出的市场反应可以对后续的产品发展方向提出建议 ​ c） 人员分配灵活，可以依据增量难度进行合理的调配 ​ d）有利于开发进度的控制 ​ e）降低了失败和更改需求的风险 ​ f）降低了有预算超出的风险 （2）缺点 ​ a）增量模型需要在开发的阶段同时进行修改，软件的整体性容易被破坏 ​ b）当增量之间出现关联，要求前一个版本要为后方定制合适的接口 螺旋模型 （1）优点 ​ a）每次交付都能得到用户的反馈，不需十分明确的需求 ​ b）项目灵活，便于应对不断变更的需求 ​ c）客户始终具有一定的项目参与度，便于开发组与客户之间的沟通 ​ d）用小的分段构造大型系统，成本计算相对容易 （2）缺点 ​ a）迭代次数难以控制，存在预算超出的风险 ​ b）不适合大团队 ​ c）难以确定发布的日期 统一过程三大特点，及与面向对象的方法的关系三大特点： 统一过程是用例驱动的：用例图要求我们站在用户的角度出发，从用户的价值层面考虑问题。同时还可以驱动系统设计、实现和测试的进行，也就是说用例可以驱动开发过程。 统一过程是以架构为中心的：软件系统的构架是从不同的角度描述即将构造的系统，它刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性。明确和可以进化的架构是用例实现的基础，所以架构必须是实现统一过程的中心。 统一过程是迭代和增量的过程：软件开发是一个复杂的过程，受控的迭代可以用来处理用例，是提高软件开发效率的关键，迭代和增量使软件开发阶段性展开，对于用例的实现做出了控制和协调。与面向对象方法的关系 统一过程本身已经成为一种流行的构造面向对象系统的迭代软件开发过程。可以说，统一过程就是一个将面向对象方法实际应用于软件开发流程的一个过程准则。在开发过程中强调对对象的描述和用例的实现，从而完成对于软件对象的定义和他们的协作模式。 统一过程四个阶段的划分，以及每个阶段的里程碑UP项目将其工作和迭代组织为四个主要阶段： 初始：大体上的构想、业务案例、范围和模糊评估 细化：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估 构造：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署 移交：进行beta测试和部署 这四个阶段的里程碑如下： 目标（生命周期目标）里程碑：目标里程碑对应初始阶段的结束，初始阶段的重点在于业务建模和需求工作，此时，开发者应该可以明确软件系统的目标和范围 架构（生命周期体系结构）里程碑：架构里程碑对应细化阶段的结束，细化阶段的重点在于设计工作，此时，开发者需要已经确定稳定的系统架构 能力（初始运行能力）里程碑：能力里程碑对应构造阶段的技术，构造阶段的重点在于实施和测试方面，此时，系统应该达到足够的稳定性和成熟性 发布（产品发布）里程碑：发布里程碑对应移交阶段的结束，移交阶段主要进行重构、修改、测试以及部署等工作，此时，需要完成系统发布和用户培训等工作 软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处统一过程模型中，各个阶段的生命周期是有固定长度的，在固定的周期内，所要完成的科目也是有明确的规范的， 因此在产品的的迭代开发过程有较为明确的时间限制的，企业能够按照统一过程的标准，按固定周期完成产品的生产和发布。 此时，根据固定周期的开发任务以及阶段，企业可以更加便利地掌控开发进度以及控制预算， 对产品的质量和生产开发过程都能进行较为精准的把控，方便企业根据实际情况做出调整，规范管理，从而尽可能达到最大的收益。]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
        <tag>points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件的本质与软件工程科学(2)]]></title>
    <url>%2F2019%2F03%2F07%2Fhw2%2F</url>
    <content type="text"><![CDATA[知识点 用简短语言给出分析与设计的理解 分析与设计的过程就是对客户提出的需求进行系统的研究，并在研究过程中对其进行精简和整理，分析过后得到可行的有价值的需求版本，然后再对其进行具体的功能与界面的设计，从而提出软件制品的可行方案。 一句话描述面向对象的分析与设计的优势 面向对象的分析与设计从客观事物的角度出发，对事物进行属性分类与行为描述，符合人为思考方式，项目的实现方式与可理解性简单。 简述UML（统一建模语言）的作用以及考试范围 UML用于将OOA（面向对象分析）与OOD（面向对象设计）用统一的符号表示出来，能够准确地呈现对象之间的关联关系以及自身行为。作为一种语言，UML能够展示项目结构，帮助项目参与者更好地理解项目。 考试的时候我们比较关注的图是用例图、静态图【类图、对象图、包图】、行为图【交互图（循序图、合作图），状态图，活动图】、实现图【构件图、部署图】 从软件的本质角度来看，软件范围（需求）控制的可行性 软件具有复杂性、一致性、可变性、不可视性。软件开发本身具有可变性，而任何微小的需求变化都可能对软件的设计开发造成很大的影响，会影响软甲开发的难度，提高复杂性，如果不对软件的需求做出控制，会无意义地增加开发难度，对软件制品的质量产生负面效果，所以控制软件需求是必须的。 在需求分析与设计的过程中，我们可以围绕软件开发的复杂性，对现有的需求进行评估，同时围绕软件开发的成本进行调控，并对其可变和不可视的环境变化，也就是意外改动进行一致性的冗余设计，由此可以使得软件生产的预算、工期、意外变化等在一定程度都在我们的掌控之中 团队kanban由于在团队中负责产品及项目管理，所以我在项目中创建了4个project用于Kanban管理，分别是前端，后台，UI和项目管理，分别由前端、后端、UI和产品方面负责的同学进行运行和维护，具体的内容在项目的readme中也有解释 一共有两种类型的列设置，一种项目管理用的management，分别有todo、in progress、need review和done，分别表示待办、进行中、待查和已完成 另一种是UI/frontend/backend三个部分的看板，分别有needtriage、high priority、in progress和close，分别表示待办、高优先级待办、进行中和已结束 UMLet绘制练习练习1：UML和模式应用（第三版）P193_图16-17 单实例类 右上角拖拽类图到左侧工作区 修改类名称：右上角添加1表示仅创建一个实例（可选） 修改类属性：属性开头结尾添加下划线 _ ，该属性呈现下划线效果 修改类方法：方法开头结尾添加下划线 _ ，该方法呈现下划线效果 练习2：UML和模式应用（第三版）P193_图16-16 关联类 拖拽类到工作区并修改内容 拖拽实线到工作区，properties改为 lt=- r1= r2= Employs 拖拽虚线到工作区，properties改为 lt=.]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
        <tag>points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min Edit Distance]]></title>
    <url>%2F2019%2F03%2F06%2FMin-Edit-Distance%2F</url>
    <content type="text"><![CDATA[用例问：最少操作多少次可以把字符串T变为S？例：S=“ABCF”，T=“DBFG”则可以 把D替换为A 删掉G 插入C 最短编辑距离概念给定两个字符串S和T，对于T，我们允许如下三个操作 在任意位置添加任一字符 删除存在的任一字符 修改任一字符 将字符串T转换成成字符串S所使用的操作次数就是编辑距离，其中，最少的操作次数就是最短编辑距离（Min Edit Distance） 算法逻辑详解向S和T中分别插入字符-，使得两个字符串相同字符尽量对齐，且两个字符串最终长度相同 如果S，T对应位置都是相同的普通字符，则不扣分，如位置2、4 如果S，T对应位置都是普通字符但不相同，则扣1分（对应修改操作），如位置1 如果S的位置为-，但是T位置是不同字符，则扣1分（对应删除操作），如位置5 如果S的位置为普通字符，但是T位置为-，则扣1分（对应增加操作），如位置3 设f(i, j)表示字符串S的前i位和T的前j位对齐后的最少扣分，则最后一位的对齐情况为 当S[i] == T[j] 时，前i-1和j-1位已经完成对齐，此时最小扣分为f(i-1, j-1) 当S[i] != T[j]时，此时最少扣分为f(i-1, j-1)+1 当S前i位和T的前j-1位已经对齐，此时最少扣分为f(i, j-1)+1 当S前i-1位和T的前j位对齐，此时最少扣分为f(i-1, j)+1 定义一个函数same(i, j)，如果S[i] == T[j]则为0表示不扣分，否则为1也就是扣分，此时f的递推表达式如下 f(i, j) = min{ f(i-1, j-1)+same(i-1, j-1), f(i-1, j)+1, f(i, j-1)+1} 初始值：f(0, j) = j, f(i, 0) = i 动态规划算法定义一个矩阵dp[m][n], 其中m=len(string1)+1，n=len(string2)+1，+1是为了避免长度为0；dp[i][j]为string1的前i个字符构成的字符串，与string2的前j个字符构成的字符串的编辑距离。 插入操作：在string1的前i个字符后插入一个新的字符，使得插入的字符等于新加入的string2[j]，插入操作对于string1来说，i没有前进，但是对于string2来说，j前进了一位，也就是说，dp[i][j] = dp[i]dp[j-1]+1 删除操作：在string1的第i个字符后删除一个字符，使得删除后的字符串string1[:i-1]与word[:j]相同，那么删除操作对于原string2来说，j没有前进，但是i前进了一位，也就是说，dp[i][j] = dp[i-1][j]+(0/1) 伪代码123456789101112131415# 初始化过程for j=0 to n do f[j] = jendfor# 连续处理for i=1 to m do last = f[0] f[0] = i for j=1 to n do temp = f[i, j] f[i, j] = min(last+same(i, 1), remp+1, temp+1, f[j-1]+1) last = temp endforendfor 算法代码]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dp</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件的本质与软件工程科学]]></title>
    <url>%2F2019%2F02%2F27%2Fhw1%2F</url>
    <content type="text"><![CDATA[软件工程a) 软件工程是指将系统化、规范化、可度量的方法应用于软件的开发、运行和维护中，即，将工程化的方法应用于软件。b) 同时，针对上述行为的相关方法的研究也是软件工程。 软件危机a) 本质原因：是计算机的发展导致了软件危机，软件具有复杂性、一致性、不可变性、可视性的本质特点，落后的软件生产方式无法满足计算机的迅速发展 b) 表现：开发和维护软件的过程中出现一系列的问题，如：开发进度难以预测、开发成本难以预测、因前期规划不善从而影响软件质量、软件产品缺少相应的文档、难以维护等 c) 克服软件危机的方法：软件工程构建了生产软件的方法与知识体系，其目标就是克服软件危机。从实践的角度，软件工程实践包括过程、方法、工具三个要素，是软件开发的最佳实践指南，当对软件开发 软件生命周期软件生命周期是指在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。 瀑布模型：按照工程次序安排开发周期，将周期分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，规定其次序并产生循环反馈 螺旋模型：该模型是快速原型法，以进化的开发方式为中心，在每个项目阶段使用瀑布模型法。这种模型的每一个周期都包括需求定义、风险分析、工程实现和评审4个阶段，由这4个阶段进行迭代。在每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定。 敏捷模型：敏捷开发以用户的需求进化为核心，最紧要的需求会被优先考虑实现，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。 火车模型：发布周期固定，每个新特性启用独立的发布火车（固定的“发车”时间，特性的状态取决于该特性是否赶上最近的火车发车时间） SWEBoK 的 15 个知识域【软件工程实践】 software requirements：软件需求，指软件产品的需求和约束，要对软件需求进行引出、商议、分析、规范和确认，保证产品的完整 software design：软件设计，指分析软件需求后，对软件制品或系统的结构、组件、接口以及其他特性做出设计和定义 software constuction：软件开发，指通过详细的设计、编码、单元测试、集成测试、调试以及验证的过程来完成开发的过程 software testing：软件测试，指通过检测行为发现当前制品的缺陷并进行改进，从而提高软件质量的行为 software maintenance：软件维护，指增强现有的软件功能、修复软件缺陷，以及使软件适应新的修改过的操作环境的过程，即软件产品的完善和迭代 software configuration management：软件配置管理，识别系统配置，从而控制配置的更改，在整个软件生命周期中保持其配置的完整性和可追溯性，包括软件配置识别、控制、状态核算、审核、软件发布管理和交付、软件配置管理工具 software engineering management：软件工程管理，指计划、协调、测量、报告和控制项目或程序，以确保软件的开发和维护是系统的、有纪律的和量化的 sofeware engineering process：软件工程过程，指对软件周期过程的定义、实现、评估、测量、管理和改进，包括过程（软件生命周期模型和过程、过程定义注释、过程适应和过程自动化）、方法（过程测量、产品测量、测量技术和测量结果质量）、工具三个方面 software engineering models and methods：软件工程模型和方法，指在不同生命周期阶段的方法，如建模、模型类型、分析、软件开发方法 software quality：软件质量，指一种软件生命周期问题，包括软件质量基础、软件质量管理过程以及实用性考量 software engineering professional practice：软件工程专业实践，指软件工程师以专业、负责和到的的方式时间软件工程所必须具备的知识、技能和态度，包括专业性、道德规范、群体动力学、沟通技巧 【软件工程基础教育】 software engineering economics：软件工程经济学，指在业务环境中作出决策，以使技术决策与组织的业务目标保持一致，包括软件工程经济学基础、非盈利决策、估算经济风险和不确定性、多属性决策 computing foundations：计算机基础，指软件工程实践必需的计算机能力，包括问题解决技术、抽象、算法和复杂性、编程基础、并行和分布式计算基础、计算机组织、操作系统以及网络通信 mathematical foundations：数学基础，指软件工程实践必需的数学能力背景，包括集合、关系和函数、基本命题和谓词逻辑、证明技术、图和树、离散概率、语法和有限状态机、数论 engineering foundations：工程基础，指软件工程实践必需的工程背景，包括经验方法和实验技术、统计分析、测量和度量、工程设计、模拟和建模、根本原因分析 CMMI 的五个级别Level 1 - Initail：无序，自发生产模型 Level 2 - Managed：项目流程特征，反应性 Level 3 - Defined：组织标准过程，可视性 Level 4 - Quantitatively Managed：测量和控制，定量的 Level 5 - Optimizing：优化和改进 SWEBokSWEBok（software engineering body of knowledge），软件工程知识体系，是IEEE Computer Society 建立的软件生产的最佳实践与相关知识的框架，指导了软件工程人才的培养与学科建设。SWEBok分为两个部分，分别是软件工程实践和软件工程基础教育，分别下设了11个和4个知识领域。 软件工程实践部分对于软件开发的流程规范进行了研究，对开发过程管理行为做出了方向性的指引，对软件开发过程中的专业性和完整性进行了分析，同时也对软件制品质量做出了保证。 软件工程基础教育部分对软件开发从业者的能力背景提出了要求，分别从经济学逻辑、计算机基础、数学基础以及工程基础对从业者做出了规范，对于学科建设和人才培养提出了具有建设性的意见。 CMMICMMI（Capability Maturity Model for Software / CMM），软件能力成熟度模型，是衡量企业能力成熟与否的模型工具。它一共分为五个层级，分别是初始级、可管理级、已定义级、量化管理级和优化管理级。 软件能力成熟度模型为企业软件工程能力的评估提出了明确的标准，根据团体能力上限的不同自底向上划分出了不同的层级，便于我们准确客观地评测企业能力。 而与此同时，CMMI的层级划分也为企业的未来发展及自身完善明确了方向，根据能力成熟度模型的层级标准，各个企业可以对自身的软件工程流程做出更加严格专业的规范，从而提高其自身能力和竞争力。]]></content>
      <categories>
        <category>system-design</category>
      </categories>
      <tags>
        <tag>homework</tag>
        <tag>points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
